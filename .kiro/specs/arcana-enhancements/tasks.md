# План реализации: Завершение системы арканов

## Обзор

Данный план описывает пошаговую реализацию четырех основных компонентов системы арканов:
1. Парсер и сериализация данных арканов
2. API endpoint для обновления профиля пользователя
3. Загрузка статей арканов в базу данных
4. Автоматическое обновление арканов в полночь
5. Интеграция всех компонентов в Calculator и CardOfDay

Реализация следует инкрементальному подходу, где каждая задача строится на предыдущих и включает валидацию через тесты.

**КРИТИЧЕСКИ ВАЖНО:** Текущий алгоритм расчета арканов в `lib/arcana/arcanaCalculator.ts` НЕВЕРЕН и должен быть обновлен на корректный алгоритм, описанный в документе требований. ВСЕ 4 аркана теперь зависят от текущей даты и меняются ежедневно.

## Задачи

- [x] 0. Обновить алгоритм расчета арканов (КРИТИЧЕСКИ ВАЖНО)
  - Открыть файл `lib/arcana/arcanaCalculator.ts`
  - Добавить функцию `calculateDateSum(date: Date): number` для расчета суммы цифр даты с учетом мастер-чисел (11, 22)
  - Добавить функцию `calculateNameSum(name: string): number` для расчета суммы букв имени (всегда однозначное)
  - Обновить функцию `calculateMorning()`: теперь `(birthDateSum + currentDateSum) mod 22`
  - Обновить функцию `calculateDay()`: теперь `(birthDateSum × currentDateSum) mod 22`
  - Обновить функцию `calculateEvening()`: теперь `(nameSum + currentDateSum) mod 22`
  - Обновить функцию `calculateNight()`: теперь `(morning + day + evening) mod 22`
  - Обновить функцию `calculateDayCard()` для использования новых формул
  - Обновить интерфейс DayCardResult при необходимости
  - Добавить комментарии с описанием нового алгоритма
  - _Требования: Все требования зависят от корректного алгоритма_

- [x] 1. Создать библиотеку сериализации данных арканов
  - Создать файл `lib/arcana/serialization.ts`
  - Реализовать функцию `serializeArcanaData()` для преобразования объекта DayCardResult в JSON строку
  - Реализовать функцию `parseArcanaData()` с валидацией структуры, типов и диапазона значений (1-22)
  - Реализовать функцию `formatArcanaForDisplay()` с поддержкой локализации (ru/en)
  - _Требования: 4.1, 4.2, 4.3, 4.5_

- [ ]* 1.1 Написать unit-тесты для библиотеки сериализации
  - Тесты для serializeArcanaData (валидные данные)
  - Тесты для parseArcanaData (валидный JSON, невалидный JSON, отсутствующие поля, значения вне диапазона)
  - Тесты для formatArcanaForDisplay (русская и английская локализация)
  - _Требования: 4.3, 4.4_

- [ ]* 1.2 Написать property-based тест для round-trip сериализации
  - **Property 10: Round-trip сериализации арканов**
  - **Проверяет: Требования 4.6**
  - Использовать fast-check для генерации случайных валидных данных арканов
  - Проверить, что parseArcanaData(serializeArcanaData(arcana)) возвращает эквивалентный объект
  - Минимум 100 итераций
  - _Требования: 4.6_

- [ ]* 1.3 Написать property-based тест для обработки невалидных данных
  - **Property 11: Обработка невалидных данных парсером**
  - **Проверяет: Требования 4.4**
  - Генерировать случайные невалидные данные (случайные строки, невалидный JSON, неправильная структура)
  - Проверить, что parseArcanaData возвращает объект с success: false и описательной ошибкой
  - Минимум 100 итераций
  - _Требования: 4.4_

- [x] 2. Создать API endpoint для обновления профиля пользователя
  - Создать файл `app/api/user/profile/route.ts`
  - Реализовать PUT handler с извлечением sessionId из cookies
  - Добавить проверку валидности сессии через AuthService.verifySession()
  - Добавить валидацию входных данных (name: строка, длина 1-100 символов)
  - Реализовать обновление поля name в таблице User через Prisma
  - Добавить обработку ошибок (401 для невалидной сессии, 400 для невалидных данных, 500 для ошибок БД)
  - Возвращать обновленные данные пользователя при успехе
  - _Требования: 2.4, 2.5, 2.6, 2.7_

- [ ]* 2.1 Написать unit-тесты для API endpoint /api/user/profile
  - Тест успешного обновления имени для аутентифицированного пользователя (200)
  - Тест возврата 401 для невалидной сессии
  - Тест возврата 400 для пустого имени
  - Тест возврата 400 для имени длиннее 100 символов
  - Использовать моки для AuthService и Prisma
  - _Требования: 2.5, 2.6, 2.7_

- [ ]* 2.2 Написать property-based тест для API валидации
  - **Property 7: API endpoint корректно обрабатывает запросы**
  - **Проверяет: Требования 2.5, 2.6, 2.7**
  - Генерировать случайные валидные и невалидные имена
  - Проверить корректность HTTP статусов для разных сценариев
  - Минимум 100 итераций
  - _Требования: 2.5, 2.6, 2.7_

- [x] 3. Загрузить статьи арканов в базу данных
  - Проверить содержимое SQL скрипта `prisma/seed-arcana-articles.sql`
  - Выполнить скрипт в Neon SQL Editor (или через Prisma migrate)
  - Проверить наличие 44 записей в таблице Article с помощью SQL запроса
  - Проверить структуру данных: relatedValue формата "arcana_{1-22}", category "Arcana (Cards)", language "ru" или "en"
  - Протестировать GET /api/articles с параметрами relatedValue и language
  - _Требования: 3.1, 3.2, 3.3, 3.4, 3.5_

- [ ]* 3.1 Написать property-based тест для структуры данных арканов в БД
  - **Property 8: Структура данных арканов в базе данных**
  - **Проверяет: Требования 3.3, 3.4, 3.5**
  - Проверить, что все записи арканов имеют корректный формат relatedValue
  - Проверить, что category всегда "Arcana (Cards)"
  - Проверить, что language всегда "ru" или "en"
  - _Требования: 3.3, 3.4, 3.5_

- [x] 4. Обновить компонент CardOfDay для загрузки статей
  - Открыть файл `components/CardOfDay.tsx`
  - Добавить state для хранения загруженных статей (Record<number, ArcanaArticle>)
  - Реализовать функцию loadArticles с параллельной загрузкой уникальных арканов через Promise.all()
  - Добавить useEffect для загрузки статей при изменении arcana или locale
  - Реализовать функцию getArticleOrPlaceholder для обработки отсутствующих статей
  - Добавить отображение title и content статьи на обратной стороне карты
  - Добавить placeholder текст "Загрузка описания..." / "Loading description..." для отсутствующих статей
  - _Требования: 3.6, 3.7, 3.8, 3.9_

- [ ]* 4.1 Написать интеграционные тесты для загрузки статей
  - Тест успешной загрузки и отображения статей арканов
  - Тест отображения placeholder при отсутствии статьи
  - Тест параллельной загрузки только уникальных арканов
  - Использовать моки для fetch API
  - _Требования: 3.7, 3.8, 3.9_

- [ ]* 4.2 Написать property-based тест для фильтрации статей по языку
  - **Property 9: Фильтрация статей по языку**
  - **Проверяет: Требования 3.7**
  - Генерировать случайные номера арканов (1-22) и языки (ru/en)
  - Проверить, что API возвращает статью на правильном языке
  - Минимум 100 итераций
  - _Требования: 3.7_

- [x] 5. Создать хук для проверки смены даты (Midnight Check)
  - Создать файл `lib/hooks/useMidnightCheck.ts`
  - Определить интерфейсы UseMidnightCheckOptions и UseMidnightCheckReturn
  - Реализовать логику setInterval для проверки даты каждую минуту (или настраиваемый интервал)
  - Добавить сравнение текущей даты с последней проверенной датой через Date.toDateString()
  - Вызывать callback onMidnight при смене даты
  - Добавить поддержку флага enabled для отключения проверки
  - Добавить cleanup (clearInterval) при размонтировании компонента
  - Возвращать lastCheckDate и isChecking из хука
  - _Требования: 1.1_

- [ ]* 5.1 Написать unit-тесты для useMidnightCheck
  - Тест вызова callback при смене даты
  - Тест отсутствия вызова callback при той же дате
  - Тест отключения проверки через enabled: false
  - Тест cleanup при размонтировании
  - Использовать jest.useFakeTimers() для симуляции времени
  - _Требования: 1.1_

- [x] 6. Интегрировать автообновление и сохранение имени в Calculator
  - [x] 6.1 Добавить поддержку сохранения даты расчета
    - Открыть файл `components/Calculator.tsx`
    - Добавить поле lastCalculationDate: string | null в state
    - Обновить функцию handleCalculate для сохранения текущей даты в ISO формате
    - Сохранять lastCalculationDate в localStorage при каждом расчете
    - Сохранять сериализованные данные арканов в localStorage через serializeArcanaData
    - _Требования: 1.6, 4.7_

  - [x] 6.2 Реализовать функцию пересчета арканов
    - Создать функцию recalculateArcana() в Calculator
    - Получить сохраненные суммы (birthDateSum, nameSum) из state
    - Вычислить сумму текущей даты с учетом мастер-чисел (11, 22)
    - **ВАЖНО:** Пересчитать ВСЕ 4 аркана по новому алгоритму:
      - Утро = (birthDateSum + currentDateSum) mod 22
      - День = (birthDateSum × currentDateSum) mod 22
      - Вечер = (nameSum + currentDateSum) mod 22
      - Ночь = (Утро + День + Вечер) mod 22
    - Использовать обновленные функции из arcanaCalculator.ts
    - Обновить state с новыми значениями ВСЕХ арканов
    - Сохранить новую дату и данные в localStorage
    - _Требования: 1.2, 1.3, 1.5, 1.7_

  - [x] 6.3 Добавить проверку при открытии страницы после полуночи
    - Добавить useEffect для проверки при монтировании компонента
    - Загрузить lastCalculationDate из localStorage
    - Сравнить сохраненную дату с текущей датой через toDateString()
    - Если даты отличаются и есть сохраненные арканы, вызвать recalculateArcana()
    - _Требования: 1.6_

  - [x] 6.4 Интегрировать useMidnightCheck для автообновления
    - Импортировать useMidnightCheck в Calculator
    - Вызвать useMidnightCheck с callback recalculateArcana
    - Установить enabled: !!state.results?.arcana (проверка только при наличии результатов)
    - Использовать checkIntervalMs: 60000 (проверка каждую минуту)
    - _Требования: 1.1, 1.2, 1.4_

  - [x] 6.5 Реализовать загрузку имени пользователя
    - Создать функцию loadUserName() в Calculator
    - Проверить наличие валидной сессии через GET /api/auth/session
    - Если сессия валидна, загрузить user.name из ответа и установить в state
    - Синхронизировать имя с localStorage
    - Если сессия невалидна, загрузить имя из localStorage как fallback
    - Добавить useEffect для вызова loadUserName при монтировании
    - _Требования: 2.2, 2.3_

  - [x] 6.6 Реализовать сохранение имени пользователя
    - Создать функцию saveUserName(name: string) в Calculator
    - Сохранить имя в localStorage синхронно
    - Проверить наличие валидной сессии
    - Если сессия валидна, отправить PUT /api/user/profile с именем
    - Обработать ошибки API без прерывания работы пользователя
    - Обновить handleCalculate для вызова saveUserName при расчете
    - _Требования: 2.1, 2.8, 2.9_

- [ ]* 6.7 Написать property-based тест для пересчета всех арканов
  - **Property 1: Все арканы пересчитываются при смене даты**
  - **Проверяет: Требования 1.2, 1.3, 1.7**
  - Генерировать случайные даты рождения, имена и даты расчета
  - Проверить, что ВСЕ арканы (Утро, День, Вечер, Ночь) пересчитываются при смене даты
  - Проверить, что для одинаковых дат результаты идентичны
  - Минимум 100 итераций
  - _Требования: 1.2, 1.3, 1.7_

- [ ]* 6.8 Написать property-based тест для пересчета при открытии страницы
  - **Property 2: Пересчет при открытии страницы после полуночи**
  - **Проверяет: Требования 1.6**
  - Симулировать сохраненную дату расчета в прошлом
  - Проверить автоматический пересчет при монтировании компонента
  - Проверить обновление даты в localStorage
  - _Требования: 1.6_

- [ ]* 6.9 Написать property-based тесты для сохранения имени
  - **Property 3: Сохранение имени аутентифицированного пользователя**
  - **Проверяет: Требования 2.1**
  - **Property 4: Сохранение имени неаутентифицированного пользователя**
  - **Проверяет: Требования 2.2**
  - **Property 5: Загрузка имени из профиля**
  - **Проверяет: Требования 2.3**
  - Генерировать случайные валидные имена
  - Проверить сохранение в БД для аутентифицированных пользователей
  - Проверить сохранение только в localStorage для неаутентифицированных
  - Проверить загрузку имени при открытии страницы
  - Минимум 100 итераций на каждое свойство
  - _Требования: 2.1, 2.2, 2.3_

- [ ]* 6.10 Написать property-based тест для синхронизации имени
  - **Property 6: Синхронизация имени между хранилищами**
  - **Проверяет: Требования 2.8, 2.9**
  - Генерировать случайные имена
  - Проверить, что localStorage и User_Profile содержат одинаковое значение после обновления
  - Проверить двунаправленную синхронизацию
  - Минимум 100 итераций
  - _Требования: 2.8, 2.9_

- [ ]* 6.11 Написать интеграционные тесты для Calculator
  - Тест автообновления арканов при смене даты (с jest.useFakeTimers)
  - Тест пересчета при открытии страницы после полуночи
  - Тест загрузки имени из профиля при монтировании
  - Тест сохранения имени в БД при расчете
  - Тест синхронизации localStorage и БД
  - _Требования: 1.2, 1.4, 1.6, 2.1, 2.3, 2.8_

- [x] 7. Финальное тестирование и проверка
  - Запустить все unit-тесты и убедиться, что они проходят
  - Запустить все property-based тесты (минимум 100 итераций каждый)
  - Запустить все интеграционные тесты
  - Выполнить ручное тестирование в браузере:
    - Проверить автообновление арканов в полночь (симулировать смену даты)
    - Проверить сохранение и загрузку имени для аутентифицированных пользователей
    - Проверить работу с localStorage для неаутентифицированных пользователей
    - Проверить загрузку статей арканов на русском и английском языках
    - Проверить отображение placeholder для отсутствующих статей
  - Проверить работу в разных часовых поясах
  - Проверить обработку ошибок (невалидная сессия, сетевые ошибки, отсутствующие статьи)
  - Проверить производительность (время загрузки статей, время пересчета)
  - Исправить найденные баги

## Примечания

- Задачи, помеченные `*`, являются опциональными и могут быть пропущены для более быстрого MVP
- Каждая задача ссылается на конкретные требования для отслеживаемости
- Property-based тесты используют библиотеку fast-check с минимум 100 итерациями
- Все тесты должны быть помечены комментарием с номером свойства и требованиями
- Checkpoint задачи (7) обеспечивают инкрементальную валидацию
- Реализация следует фазам из документа дизайна для минимизации зависимостей
